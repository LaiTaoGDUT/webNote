

### **1. 内存结构与生命周期**
浏览器内存分为 **栈（Stack）** 和 **堆（Heap）**：
- **栈**：存储原始类型（如 `number`、`boolean`）和函数调用时的临时变量，由系统自动分配和释放（LIFO）。
- **堆**：存储对象、数组、闭包等复杂类型，由垃圾回收器动态管理。

#### **对象生命周期**
1. **分配**：通过 `new`、字面量、函数调用等创建对象。
2. **使用**：对象被变量、属性或闭包引用。
3. **不可达（Unreachable）**：对象不再被任何根对象（Root）引用。
4. **回收**：垃圾回收器释放其内存。

  根对象有哪些：

1. **全局对象（Global Objects）**  
   - `window` 对象（浏览器全局作用域）。  
   - `globalThis`（ES6+ 中跨环境的全局对象）。  
   - 全局变量（如 `var` 定义的变量，或直接挂载到 `window` 的属性）。

2. **DOM 树的根节点**  
   - `document` 对象及其直接引用的 DOM 元素。  
   - 当前页面中未被移除的 DOM 元素（如 `<body>`、`<html>` 等）。

3. **活动引用（Active References）**  
   - 正在执行的函数中的局部变量和参数（调用栈中的引用）。  
   - 未完成的异步操作（如 `setTimeout`、`setInterval`、未完成的 `Promise`）。  
   - 事件监听器（如未被移除的 `addEventListener` 绑定的回调函数）。

4. **其他特殊引用**  
   - `console` 保留的调试引用（如 `console.log` 输出的对象可能被保留）。  
   - Web API 对象（如 `XMLHttpRequest`、`WebSocket` 的实例，直到它们完成或关闭）。

---


---

### **2. 核心算法详解**

#### **(1) 标记-清除（Mark-Sweep）**
- **根对象（Roots）**：
  - 全局变量（如 `window`、`globalThis`）。
  - 当前执行函数的局部变量和参数（调用栈）。
  - DOM 树中的活动节点（未被删除的节点）。
  - 其他活动对象（如定时器、事件监听器）。
  
- **标记阶段**：
  - 从根对象出发，递归遍历所有可达对象，标记为“存活”。
  - 使用 **三色标记法**（白、灰、黑）优化遍历：
    - **白色**：未访问。
    - **灰色**：已发现但子引用未遍历。
    - **黑色**：已遍历且所有子引用已处理。

- **清除阶段**：
  - 遍历整个堆，释放未被标记的内存块。
  - **缺点**：产生内存碎片（空闲内存不连续）。

#### **(2) 标记-整理（Mark-Compact）**
- 在标记后，将存活对象向内存一端移动，消除碎片。
- **优点**：提高内存利用率，适合老生代。
- **缺点**：移动对象需要额外计算，耗时长。

#### **(3) 引用计数（已淘汰）**
- **原理**：每个对象维护一个引用计数器，引用增减时更新。
- **致命缺陷**：
  - 循环引用导致计数器永不为零（如 `A → B → A`）。
  - 频繁更新计数器性能差。

---

### **3. 分代回收（Generational Collection）**
基于 **弱分代假说**：大多数对象生命周期极短，少数长期存活。

#### **(1) 新生代（Young Generation）**
- **内存划分**：
  - 使用 **Semi-space 设计**，分为 `From-Space` 和 `To-Space`。
  - 默认较小（如 V8 中约 16MB），仅存放临时对象。
  
- **Scavenge 算法（复制算法）**：
  1. 新对象分配到 `From-Space`。
  2. 当 `From-Space` 满时触发 **Minor GC**：
     - 标记存活对象。
     - 将存活对象复制到 `To-Space`，并更新引用地址。
     - 清空 `From-Space`，交换 `From` 和 `To` 角色。
  3. **晋升（Promotion）**：
     - 对象存活超过一轮 GC，或 `To-Space` 使用超过 25%，则晋升至老生代。

- **优点**：速度快（只处理存活对象，空间小）。
- **缺点**：浪费 50% 内存空间（双缓冲区设计）。

#### **(2) 老生代（Old Generation）**
- **内存管理**：
  - 使用连续内存块，存放长期存活对象或大对象（如 V8 中超过 1MB 直接进入老生代）。
  - 结合 **标记-清除**（快速回收）和 **标记-整理**（减少碎片）。
  
- **Major GC 触发条件**：
  - 老生代内存不足。
  - 新生代晋升的对象导致老生代空间不足。
  - 手动调用 `window.gc()`（仅限开发模式）。

---

### **4. 优化策略与高级技术**

#### **(1) 增量标记（Incremental Marking）**
- **问题**：单次标记可能阻塞主线程数百毫秒，导致页面卡顿。
- **解决方案**：
  - 将标记过程拆分为多个小步骤（如每 10ms 执行一次）。
  - 主线程在步骤间继续执行 JavaScript 或渲染任务。
- **实现**：使用 **写屏障（Write Barrier）** 跟踪对象引用变化，确保标记一致性。

#### **(2) 并发回收（Concurrent GC）**
- **目标**：GC 线程与主线程并行执行。
- **挑战**：JavaScript 可能在回收时修改对象引用，导致数据竞争。
- **解决方案**：
  - **三色标记 + 写屏障**：当主线程修改对象引用时，通过屏障记录变化，GC 线程重新检查。
  - V8 的 **Orinoco 项目**：实现并发标记和惰性清理。

#### **(3) 空闲时间回收（Idle-Time GC）**
- 利用浏览器空闲时段（如 `requestIdleCallback`）执行低优先级 GC 任务。

---

### **5. 内存泄漏的常见场景**
#### **(1) 意外全局变量**
```javascript
function leak() {
  leakedData = new Array(1e6); // 未用 var/let/const 声明，成为全局变量
}
```

#### **(2) 未清理的引用**
```javascript
const button = document.getElementById('btn');
button.addEventListener('click', onClick); // 即使按钮被移除，监听器仍保留引用
// 需手动移除：button.removeEventListener('click', onClick);
```

#### **(3) 闭包**
```javascript
function createClosure() {
  const largeData = new Array(1e6);
  return function() {
    console.log(largeData); // largeData 被闭包引用，无法释放
  };
}
const fn = createClosure();
```

#### **(4) 脱离的 DOM 引用**
```javascript
let domElement = document.getElementById('list');
document.body.removeChild(domElement); // DOM 被移除
domElement = null; // 需手动解除引用，否则 JavaScript 仍持有 DOM 对象
```

---

### **6. V8 引擎的 GC 实现细节**
#### **(1) 并行回收**
- **Minor GC**：使用多个辅助线程并行复制对象。
- **Major GC**：主线程标记，辅助线程并行清理和整理。

#### **(2) 增量标记的步骤**
1. 主线程暂停 JavaScript 执行，启动标记。
2. 标记任务分片执行，每片完成后让出主线程。
3. 写屏障记录标记期间的对象修改。
4. 最终暂停主线程完成剩余标记。

#### **(3) 内存限制**
- 浏览器标签页的堆内存上限通常为 1~4GB（不同浏览器策略不同）。
- Node.js 可通过 `--max-old-space-size` 调整老生代大小。

---

### **7. 调试与分析工具**

#### **(1) Chrome DevTools**
- **Memory 面板**：
  - **Heap Snapshot**：捕获堆内存快照，分析对象分布。
  - **Allocation Timeline**：跟踪内存分配时间线，定位泄漏点。
  - **Allocation Sampling**：统计函数内存分配占比。
- **Performance 面板**：记录内存变化曲线，观察 GC 频率。

#### **(2) 代码实践**
```javascript
// 手动触发 GC（仅限开发环境）
window.gc(); // Chrome 需启动时加参数 --js-flags="--expose-gc"

// 使用 WeakRef 观察对象回收
const ref = new WeakRef({ data: 'test' });
setTimeout(() => {
  console.log(ref.deref()); // 可能已返回 undefined
}, 10000);
```

---

### **8. 不同引擎的 GC 策略对比**
| **引擎**          | **V8 (Chrome/Node.js)**       | **SpiderMonkey (Firefox)**       | **JavaScriptCore (Safari)**      |
|-------------------|------------------------------|----------------------------------|----------------------------------|
| **新生代算法**     | Scavenge（复制）              | Nursery（类似 Scavenge）         | Copying GC                       |
| **老生代算法**     | 标记-清除 + 标记-整理         | 标记-清除 + 增量整理              | 标记-清除 + 分块整理              |
| **并发回收**       | 并行标记 + 惰性清理           | 增量标记 + 并发清理               | 并发标记 + 并行清理               |
| **触发策略**       | 内存压力驱动 + 时间启发式      | 内存阈值触发 + 空闲任务            | 动态调整阈值 + 低延迟优化         |

---

### **9. 最佳实践**
1. **减少全局变量**：使用严格模式（`'use strict'`）避免意外全局变量。
2. **及时释放引用**：移除不再需要的定时器、事件监听器和 DOM 引用。
3. **优化数据结构**：避免嵌套过深的对象，使用 `TypedArray` 处理二进制数据。
4. **控制内存峰值**：分块处理大数据（如分批处理数组），避免单次操作占用过多内存。

---

通过深入理解垃圾回收机制，开发者可以更高效地管理内存，避免性能瓶颈，并构建更健壮的 Web 应用。