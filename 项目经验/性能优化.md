#### 如何着手排查页面性能问题

1. 浏览器打开页面与控制台，先看`Network`面板，查看请求的资源
    - 首屏拆分的js资源是否过多，是否存在部分js资源很小，可合并到其他js资源中，减少请求
    - 首屏拆分的js资源是否过少，是否存在部分js资源很大，和拆分成多个js资源，利用并行请求加快请求速度
    - 首屏加载js资源是否过大，执行`npm run analyzer`查看各个js资源情况，是否可移除部分未使用的npm包，是否可拆分部分非首屏必须的npm包或业务代码改为单独打包并延迟加载，是否由于`webpack`配置错误导致部分代码重复打包到多个js中，是否将过多小图片打包为base64，考虑使用雪碧图
    - 图片资源过大，查看图片是否可压缩，替换压缩后的图片
    - 图片资源一次性加载过多，通常为批量渲染一个列表的图片，列表内的图片是否可改为懒加载
    - 首屏加载css资源过大，查看源代码，是否使用过多重复的样式声明或使用过多`mixin`，相同样式提取到父元素/单一class，`extend`代替`mixin`

2. 再看`Performance`面板，分析页面首屏加载情况
    - 各个资源是否正常并行请求，如发现串行加载，考虑html是否带有`Upgrade-Insecure-Requests`的`meta`头，检查业务代码是否存在`http`请求，考虑改为`https`并移除此标头
    - 排查是否存在首屏js资源串行加载，检查vue-router内是否将需要首屏打开的路由页面页也采用了动态import（导致首屏路由页面打包出了单独的js，在首屏其他js都加载完成后执行力new vue之后才进行加载）
    - 首屏渲染前都执行了哪些操作，是否存在部分堵塞渲染的耗时高操作，是否可改为非堵塞操作/延迟执行，比如`svga`播放库的解压操作耗时高，改为首屏渲染完成后空闲时间进行解压
    - 是否存在非业务js资源首屏加载堵塞渲染（比如一些广告分析插件等），改为使用`async`或`defer`

3. 再看页面本身的UI与逻辑
    - 从页面可见到可交互期间，需要等待哪些操作，请求了多少接口，是否存在需串行等待请求的接口，是否可合并接口减少接口请求数以及请求时间，非立即展示的数据（比如用户交互后才展示的弹窗内数据）可改为交互后请求加载
    - 首屏页面哪些页面元素是次要的，是否可延迟初始化/滚动到可见时才初始化

#### CSS方面

1. 减少重复的css代码，比如相同样式迁移到父元素或者使用公共类，减少mixins的使用，改为extend等

2. v-show动态控制的元素，使用backgroundImage样式来加载替代img标签，以便在展示时才加载img资源

#### JavaScript方面

1. 延迟非首屏资源或者首屏次要资源的加载，比如顶部的弹幕列表和卡片闪光svga动画设置延迟两秒后才加载，底部话题列表在滚动到可见区域时才加载

2. 非首屏依赖的npm包单独打包，在需要用到时动态引入，比如动态引入svga播放库，在需要时才加载播放库播放: `(await import('@bigo/svgaplayerweb')).default;`

3. 首屏路由不采用懒加载，非首屏路由采用懒加载

4. 减少`import *`和`export *`的使用，避免暗中引入没用到的资源，比如将 `import { xxx } from 'COMMON/utils'`  改为 `import { xxx } from 'COMMON/utils/xxx';`

#### VUE方面

##### 1. **组件级优化**

- **拆分组件**：将大型组件拆分为更小的、功能单一的组件，减少重复渲染范围。

- **异步组件 & 懒加载**：使用 `() => import('./Component.vue')` 实现路由懒加载或动态组件按需加载。

- **合理使用 `keep-alive`**：缓存高频切换的组件（如 Tab 页），避免重复渲染。
```javaScript
<keep-alive>
    <component :is="currentComponent"></component>
</keep-alive>
```

##### 2. **列表渲染优化**

- **始终为 `v-for` 设置唯一 `key`**：帮助 Vue 高效复用 DOM。

- **虚拟滚动**：长列表使用 `vue-virtual-scroller` 等库，仅渲染可见区域元素。

- **避免 `v-if` 和 `v-for` 同时使用**：优先用计算属性过滤数据，再渲染。

#### HTML方面

1. 移除html文件中带有`Upgrade-Insecure-Requests`的`meta`头，该头会导致所有首屏js资源和css资源串行请求

2. 在模板html的`<div id="app"></div>`内，插入骨架屏代码，一般先用骨架屏插件生成初步的骨架屏，再根据需要手动调整

#### 接口方面

1. 合并首屏的串行接口请求，减少首屏接口数量

2. 次要的数据展示接口改为需要显示目标数据时再请求

#### webpack打包方面

1. 使用`url-loader`/`assets`配置转成`base64`的图片数量过多导致`js`包体过大，应该降低转换的大小限制（一般用4kb，可适当降低），或使用`webpack-spritesmith`将部分小图片合成雪碧图加载

2. 通过`Webpack Bundle Analyzer`分析打包出来的包体结构，如有体积过大的单个包体，考虑通过配置拆分多个包以利用并行加载能力，如有体积过小的包体，考虑合并到其他包体中以减少浏览器请求数量。